<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kalpa - Organismo V7 (Opacidad Fix + Escala Color)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- ========================================== -->
    <!-- SHADERS: ORGANISMO VIVO -->
    <!-- ========================================== -->

    <!-- Vertex Shader: Geometría Dinámica (LIMPIO) -->
    <script type="x-shader/x-vertex" id="vertexshader">
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        varying vec3 vPos;
        varying float vDist; 
        
        uniform float uTime;
        uniform float uSpeed; 
        uniform float uBreathIntensity; 
        
        // PARAMETROS REACTIVOS
        uniform float uTubeThickness; 
        
        // Audio Displacement
        uniform float uAudioDisplace;

        void main() {
            vUv = uv;
            vNormal = normalize(normalMatrix * normal);
            vPos = position; 
            
            // 1. Respiración Orgánica
            float breath = sin(uTime * 1.5) * uBreathIntensity * 5.0;
            
            // 3. Modificación de Vértice
            // Solo respiración + grosor base + golpe de audio
            vec3 newPos = position + normal * (breath + uTubeThickness + uAudioDisplace);

            vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
            vViewPosition = -mvPosition.xyz; 
            
            vDist = length(mvPosition.xyz);
            
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <!-- Fragment Shader: Piel Etérea con Niebla -->
    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform float uTime;
        
        uniform float uSpeed;           
        uniform float uOpacityBase;     
        uniform float uFresnelIntensity;
        uniform float uColorSaturation;
        uniform float uColorScale;
        
        const float fogNear = 1000.0;
        const float fogFar = 2800.0;

        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        varying vec3 vPos;
        varying float vDist;

        // --- RUIDO 3D (Mantenemos el ruido solo para el COLOR, no para la forma) ---
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

        float snoise(vec3 v) {
            const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
            const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i  = floor(v + dot(v, C.yyy) );
            vec3 x0 = v - i + dot(i, C.xxx) ;
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute( permute( permute(
                        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
            float n_ = 0.142857142857;
            vec3  ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
        }

        vec3 spectralPalette(float t) {
            vec3 a = vec3(0.5, 0.5, 0.5);
            vec3 b = vec3(0.5, 0.5, 0.5);
            vec3 c = vec3(1.0, 1.0, 1.0);
            vec3 d = vec3(0.00, 0.33, 0.67);
            return a + b * cos(6.28318 * (c * t + d));
        }

        void main() {
            vec3 viewDir = normalize(vViewPosition);
            vec3 normal = normalize(vNormal);

            float timeFactor = uTime * uSpeed * 0.2; 
            
            // Usamos uColorScale para controlar el tamaño del patrón de colores
            vec3 posScaled = vPos * uColorScale;
            
            vec3 posAnimated1 = posScaled - vec3(timeFactor, 0.0, 0.0);
            vec3 posAnimated2 = posScaled * 1.5 - vec3(timeFactor * 1.2, 0.0, 0.0);

            float n1 = snoise(posAnimated1);
            float n2 = snoise(posAnimated2);
            float fluid = n1 * 0.6 + n2 * 0.4;

            vec3 baseColor = spectralPalette(fluid * 0.8 + timeFactor * 0.5);
            
            // Saturación
            vec3 color = pow(baseColor, vec3(2.0 - uColorSaturation)); 

            float fresnelBase = pow(1.0 - abs(dot(normal, viewDir)), 2.5);
            vec3 finalColor = color + vec3(0.8) * fresnelBase;
            
            float alpha = uOpacityBase + fresnelBase * uFresnelIntensity;

            // --- FOG ---
            float fogFactor = smoothstep(fogNear, fogFar, vDist);
            alpha *= (1.0 - fogFactor);

            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>

    <style>
        :root {
            --primary-glow: #4DDBFF;
            --secondary-glow: #FF4DDB;
            --panel-bg: rgba(5, 12, 25, 0.85);
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: 'Courier New', monospace;
            user-select: none;
            -webkit-user-select: none;
        }

        #debug-info {
            position: absolute; top: 20px; left: 20px; pointer-events: none;
            color: rgba(255, 255, 255, 0.6); font-size: 11px; z-index: 10;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); letter-spacing: 1px;
            mix-blend-mode: screen;
        }

        /* --- AUDIO UI --- */
        #audio-controls {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            z-index: 100; display: flex; flex-direction: column; align-items: center; gap: 10px;
            pointer-events: auto;
        }
        
        .upload-btn {
            background: rgba(10, 20, 40, 0.6);
            border: 1px solid var(--primary-glow);
            color: var(--primary-glow);
            padding: 10px 20px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 12px;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(77, 219, 255, 0.2);
            backdrop-filter: blur(5px);
        }
        .upload-btn:hover {
            background: var(--primary-glow);
            color: #000;
            box-shadow: 0 0 20px var(--primary-glow);
        }

        #file-input { display: none; }
        
        #audio-status {
            font-size: 10px; color: rgba(255,255,255,0.7); opacity: 0; transition: opacity 0.5s;
            text-align: center;
        }

        #play-controls {
            display: none; /* Se muestra al cargar audio */
            gap: 15px;
            align-items: center;
        }

        .control-icon {
            font-size: 24px; color: white; cursor: pointer; transition: transform 0.2s;
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.5));
        }
        .control-icon:hover { transform: scale(1.2); color: var(--primary-glow); }

        /* --- UI PANEL --- */
        #config-toggle {
            position: absolute; top: 20px; right: 20px; z-index: 200;
            width: 40px; height: 40px; border-radius: 50%;
            background: rgba(10, 20, 40, 0.8); border: 1px solid var(--primary-glow);
            color: var(--primary-glow); display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.3s ease; pointer-events: auto;
        }
        #config-toggle:hover { transform: rotate(90deg); box-shadow: 0 0 15px var(--primary-glow); }

        #config-panel {
            position: absolute; top: 70px; right: 20px; width: 300px;
            background: rgba(5, 12, 25, 0.95); border: 1px solid rgba(77, 219, 255, 0.3);
            border-radius: 12px; padding: 20px; backdrop-filter: blur(10px);
            z-index: 199; transform: translateX(120%); transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: -10px 10px 30px rgba(0,0,0,0.8); pointer-events: auto;
            color: #EAEAEA; font-family: 'Courier New', monospace;
            max-height: 80vh; overflow-y: auto;
        }
        #config-panel.open { transform: translateX(0); }
        
        .config-item { margin-bottom: 15px; }
        .config-label { display: flex; justify-content: space-between; color: #94a3b8; font-size: 0.8rem; margin-bottom: 5px; }
        .config-val { color: var(--primary-glow); font-weight: bold; }
        
        input[type=range] { width: 100%; -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%;
            background: var(--primary-glow); cursor: pointer; margin-top: -6px;
            box-shadow: 0 0 10px var(--primary-glow);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: rgba(255,255,255,0.2); border-radius: 2px;
        }
        input[type=range]:focus { outline: none; }

        .btn-reset {
            width: 100%; padding: 8px; margin-top: 10px;
            background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255,255,255,0.2);
            color: #aaa; font-size: 0.8rem; cursor: pointer; border-radius: 4px;
            transition: all 0.2s;
        }
        .btn-reset:hover { background: rgba(255, 68, 68, 0.2); border-color: rgba(255, 68, 68, 0.5); color: #ffadad; }

        /* --- VISUALIZADOR --- */
        #visualizer-canvas {
            position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
            width: 300px; height: 50px; pointer-events: none; opacity: 0.5;
        }

        #touch-controls {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            width: 100%; height: 100%; pointer-events: none; z-index: 999;
            display: none; 
        }
        #joystick-container {
            position: absolute; bottom: 50px; left: 50px;
            width: 120px; height: 120px;
            background: radial-gradient(circle, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0) 60%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%; display: flex; justify-content: center; align-items: center;
            pointer-events: auto;
        }
        #joystick-knob {
            width: 40px; height: 40px; background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%; position: absolute;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
            transition: transform 0.05s; backdrop-filter: blur(2px);
        }
        #hyperspace-btn {
            position: absolute; bottom: 50px; right: 50px;
            width: 80px; height: 80px; border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, rgba(0,0,0,0) 60%);
            pointer-events: auto; display: flex; justify-content: center; align-items: center;
            font-size: 24px; color: rgba(255, 255, 255, 0.6);
        }
        
        canvas { display: block; }
    </style>
</head>
<body>

    <div id="debug-info">
        KALPA AUDIO-REACTIVO<br>
        <span style="color:rgba(255,255,255,0.4)">WASD: Mover | Q/E: Mirar Arriba/Abajo | Espacio: Acelerar</span>
    </div>

    <!-- AUDIO CONTROLS -->
    <canvas id="visualizer-canvas"></canvas>
    <div id="audio-controls">
        <label for="file-input" class="upload-btn">
            <i class="fas fa-music"></i> Subir Audio
        </label>
        <input type="file" id="file-input" accept="audio/*">
        
        <div id="audio-status">Esperando archivo...</div>
        
        <div id="play-controls">
            <i class="fas fa-play control-icon" id="btn-play"></i>
            <i class="fas fa-pause control-icon" id="btn-pause" style="display:none"></i>
        </div>
    </div>

    <!-- BOTÓN Y PANEL DE CONFIGURACIÓN -->
    <button id="config-toggle"><i class="fas fa-cog"></i></button>
    
    <div id="config-panel">
        <h3 style="color:var(--primary-glow); text-align:center; margin-bottom:15px; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:10px;">
            Biometría
        </h3>

        <div class="config-item" style="background: rgba(77, 219, 255, 0.1); padding: 10px; border-radius: 8px;">
            <div class="config-label"><span style="color:white">Compresión (Vueltas)</span><span id="val-density" class="config-val">3.0</span></div>
            <input type="range" id="input-density" min="0.5" max="8.0" step="0.1" value="3.0">
        </div>

        <div class="config-item">
            <div class="config-label">
                <span>Reactividad Audio</span>
                <span id="val-audioreact" class="config-val" style="color:var(--secondary-glow)">1.0</span>
            </div>
            <input type="range" id="input-audioreact" min="0" max="3.0" step="0.1" value="1.0">
        </div>

        <div class="config-item">
            <div class="config-label"><span>Vida (Respiración)</span><span id="val-breath" class="config-val">0.5</span></div>
            <input type="range" id="input-breath" min="0" max="2.0" step="0.1" value="0.5">
        </div>

        <!-- CONTROL DE SATURACIÓN -->
        <div class="config-item">
            <div class="config-label"><span>Saturación Color</span><span id="val-color" class="config-val">1.2</span></div>
            <input type="range" id="input-color" min="0.0" max="3.0" step="0.1" value="1.2">
        </div>

        <!-- NUEVO: CONTROL DE ESCALA DE COLOR -->
        <div class="config-item">
            <div class="config-label"><span>Tamaño Colores</span><span id="val-scale" class="config-val">0.05</span></div>
            <!-- Rango pequeño para escala fina -->
            <input type="range" id="input-scale" min="0.005" max="0.15" step="0.005" value="0.05">
        </div>

        <div class="config-item">
            <div class="config-label"><span>Grosor Arteria</span><span id="val-thickness" class="config-val">0.0</span></div>
            <input type="range" id="input-thickness" min="-10.0" max="20.0" step="0.5" value="0.0">
        </div>

        <div class="config-item">
            <div class="config-label"><span>Velocidad Flujo</span><span id="val-speed" class="config-val">1.0</span></div>
            <input type="range" id="input-speed" min="0" max="5.0" step="0.1" value="1.0">
        </div>

        <div class="config-item">
            <div class="config-label"><span>Opacidad Piel</span><span id="val-opacity" class="config-val">0.15</span></div>
            <input type="range" id="input-opacity" min="0" max="1.0" step="0.01" value="0.15">
        </div>

        <div class="config-item">
            <div class="config-label"><span>Intensidad Borde</span><span id="val-fresnel" class="config-val">0.55</span></div>
            <input type="range" id="input-fresnel" min="0" max="2.0" step="0.05" value="0.55">
        </div>

        <button class="btn-reset" id="btn-reset">Reiniciar Organismo</button>
    </div>

    <div id="touch-controls">
        <div id="joystick-container">
            <div id="joystick-knob"></div>
        </div>
        <div id="hyperspace-btn">⚡</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- SISTEMA DE AUDIO (NUEVO) ---
        const AudioSystem = {
            context: null,
            analyser: null,
            source: null,
            dataArray: null,
            isPlaying: false,
            // Bandas de frecuencia normalizadas (0.0 a 1.0)
            lows: 0,
            mids: 0,
            highs: 0,
            volume: 0,
            reactivity: 1.0, // Multiplicador general controlable por usuario

            init() {
                const fileInput = document.getElementById('file-input');
                const playBtn = document.getElementById('btn-play');
                const pauseBtn = document.getElementById('btn-pause');

                fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                playBtn.addEventListener('click', () => this.play());
                pauseBtn.addEventListener('click', () => this.pause());
            },

            setupContext() {
                if (!this.context) {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.context.createAnalyser();
                    this.analyser.fftSize = 512; // Resolución de análisis
                    this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                }
                if (this.context.state === 'suspended') {
                    this.context.resume();
                }
            },

            handleFileSelect(e) {
                const file = e.target.files[0];
                if (!file) return;

                const status = document.getElementById('audio-status');
                status.style.opacity = 1;
                status.innerText = "Cargando: " + file.name;

                this.setupContext();

                const reader = new FileReader();
                reader.onload = (ev) => {
                    this.context.decodeAudioData(ev.target.result, (buffer) => {
                        this.stop(); // Detener anterior si existe
                        
                        this.buffer = buffer; // Guardamos el buffer decodificado
                        this.play();
                        
                        status.innerText = "Reproduciendo: " + file.name;
                        document.getElementById('play-controls').style.display = 'flex';
                        document.querySelector('.upload-btn').style.display = 'none'; // Ocultar boton subida para limpiar UI
                    }, (err) => {
                        console.error(err);
                        status.innerText = "Error al decodificar audio";
                    });
                };
                reader.readAsArrayBuffer(file);
            },

            play() {
                if (!this.buffer) return;
                this.setupContext();
                
                // Si estaba pausado pero tenemos buffer, recreamos la fuente
                // (Web Audio API requiere recrear source node cada vez)
                this.source = this.context.createBufferSource();
                this.source.buffer = this.buffer;
                this.source.connect(this.analyser);
                this.analyser.connect(this.context.destination);
                
                this.source.start(0);
                this.isPlaying = true;

                document.getElementById('btn-play').style.display = 'none';
                document.getElementById('btn-pause').style.display = 'block';
            },

            pause() {
                if (this.source) {
                    this.source.stop();
                    this.isPlaying = false;
                }
                document.getElementById('btn-play').style.display = 'block';
                document.getElementById('btn-pause').style.display = 'none';
            },

            stop() {
                if (this.source) {
                    try { this.source.stop(); } catch(e){}
                    this.source = null;
                }
                this.isPlaying = false;
            },

            update() {
                if (!this.isPlaying || !this.analyser) {
                    // Decay suave a cero si no suena nada
                    this.lows *= 0.95;
                    this.mids *= 0.95;
                    this.highs *= 0.95;
                    this.volume *= 0.95;
                    return;
                }

                this.analyser.getByteFrequencyData(this.dataArray);

                // Calcular bandas promedio
                let lowSum = 0, midSum = 0, highSum = 0;
                const binCount = this.analyser.frequencyBinCount; // 256
                
                // Bajos: Primeros 10%
                const lowLimit = Math.floor(binCount * 0.1);
                // Medios: 10% a 50%
                const midLimit = Math.floor(binCount * 0.5);

                for (let i = 0; i < binCount; i++) {
                    const val = this.dataArray[i] / 255.0; // Normalizar 0-1
                    if (i < lowLimit) lowSum += val;
                    else if (i < midLimit) midSum += val;
                    else highSum += val;
                }

                // Promediar y suavizar (Smoothing)
                const targetLows = lowSum / lowLimit;
                const targetMids = midSum / (midLimit - lowLimit);
                const targetHighs = highSum / (binCount - midLimit);

                // Interpolación lineal para suavidad (Lerp)
                this.lows += (targetLows - this.lows) * 0.2;
                this.mids += (targetMids - this.mids) * 0.2;
                this.highs += (targetHighs - this.highs) * 0.2;
                
                // Volumen general
                this.volume = (this.lows + this.mids + this.highs) / 3.0;

                // Dibujar visualizador simple
                this.drawVisualizer();
            },

            drawVisualizer() {
                const canvas = document.getElementById('visualizer-canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 300; canvas.height = 50;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const barWidth = (canvas.width / this.analyser.frequencyBinCount) * 2.5;
                let x = 0;
                
                for(let i = 0; i < this.analyser.frequencyBinCount; i++) {
                    const barHeight = (this.dataArray[i] / 255) * canvas.height;
                    
                    // Color basado en intensidad
                    const r = barHeight + (25 * (i/this.analyser.frequencyBinCount));
                    const g = 250 * (i/this.analyser.frequencyBinCount);
                    const b = 255;

                    ctx.fillStyle = `rgb(${r},${g},${b})`;
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
            }
        };


        // --- GESTOR DE CONFIGURACIÓN ---
        const ConfigManager = {
            defaults: {
                speed: 1.0,
                opacityBase: 0.15,
                fresnelIntensity: 0.55,
                colorSaturation: 1.2,
                colorScale: 0.05,
                breathIntensity: 0.5,
                waveFrequency: 0.05,
                tubeThickness: 0.0,
                springDensity: 3.0,
                audioReactivity: 1.0 
            },
            current: {},
            
            init() {
                const saved = localStorage.getItem('kalpa_bio_config_v7');
                if (saved) {
                    this.current = { ...this.defaults, ...JSON.parse(saved) };
                    if(this.current.audioReactivity === undefined) this.current.audioReactivity = 1.0;
                } else {
                    this.current = { ...this.defaults };
                }
                this.bindUI();
                this.updateUI();
                
                document.getElementById('config-toggle').addEventListener('click', () => {
                    document.getElementById('config-panel').classList.toggle('open');
                });

                document.getElementById('btn-reset').addEventListener('click', () => {
                    this.current = { ...this.defaults };
                    this.save();
                    this.updateUI();
                    this.applyToWorld();
                    rebuildWorld(); 
                });
            },

            bindUI() {
                const bind = (id, key, requiresRebuild = false) => {
                    const el = document.getElementById(id);
                    if (!el) return; // Safety check
                    const valEl = document.getElementById(id.replace('input-', 'val-'));
                    el.addEventListener('input', (e) => {
                        const val = parseFloat(e.target.value);
                        this.current[key] = val;
                        
                        if(valEl) {
                            if(key === 'colorScale' || key === 'waveFrequency') valEl.innerText = val.toFixed(3);
                            else valEl.innerText = val.toFixed(2);
                        }
                        
                        this.save();
                        
                        if (requiresRebuild) rebuildWorld();
                        else this.applyToWorld();
                    });
                };
                bind('input-speed', 'speed');
                bind('input-opacity', 'opacityBase');
                bind('input-fresnel', 'fresnelIntensity');
                bind('input-breath', 'breathIntensity');
                // bind('input-wavefreq', 'waveFrequency'); 
                bind('input-thickness', 'tubeThickness');
                bind('input-color', 'colorSaturation');
                bind('input-scale', 'colorScale'); // NUEVO: Vinculamos el slider
                bind('input-density', 'springDensity', true);
                bind('input-audioreact', 'audioReactivity'); 
            },

            updateUI() {
                const update = (id, key) => {
                    const val = this.current[key];
                    const el = document.getElementById(id);
                    if(el) el.value = val;
                    const valEl = document.getElementById(id.replace('input-', 'val-'));
                    if(valEl) {
                         if(key === 'colorScale') valEl.innerText = val.toFixed(3);
                         else valEl.innerText = val.toFixed(2);
                    }
                };
                update('input-speed', 'speed');
                update('input-opacity', 'opacityBase');
                update('input-fresnel', 'fresnelIntensity');
                update('input-breath', 'breathIntensity');
                update('input-thickness', 'tubeThickness');
                update('input-color', 'colorSaturation');
                update('input-scale', 'colorScale'); // NUEVO
                update('input-density', 'springDensity');
                update('input-audioreact', 'audioReactivity');
            },

            save() {
                localStorage.setItem('kalpa_bio_config_v7', JSON.stringify(this.current));
            },

            applyToWorld() {
                // Aplicamos solo los valores BASE. La modulación de audio se hace en animate()
            }
        };

        // --- MOTOR INFINITO ---
        const SEGMENT_LENGTH = 1000;
        const SEGMENT_RADIUS = 60;
        const VISIBLE_SEGMENTS = 5; 
        
        let scene, camera, renderer, clock;
        let activeSegments = [];
        let minZ = 0, maxZ = 0;

        const NORMAL_SPEED = 150.0;
        const TURBO_SPEED = 600.0;
        let currentSpeed = 0;
        
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let moveUp = false, moveDown = false, isTurbo = false;
        let rotateLeft = false, rotateRight = false;
        let pitch = 0, yaw = 0, roll = 0;
        let isMouseDown = false;
        let isTouchDevice = false, joystickActive = false, joystickId = null;
        let joystickCenter = { x: 0, y: 0 };
        const joystickMaxRadius = 40;
        const joystickKnob = document.getElementById('joystick-knob');
        const joystickContainer = document.getElementById('joystick-container');
        const hyperspaceBtn = document.getElementById('hyperspace-btn');

        function init() {
            ConfigManager.init();
            AudioSystem.init();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); 

            clock = new THREE.Clock();

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 5000);
            camera.rotation.order = "YXZ"; 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            initWorldSegments();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', (e) => {
                if (e.target.closest('#config-panel') || e.target.closest('#config-toggle') || e.target.closest('#audio-controls')) return;
                isMouseDown = true;
            });
            document.addEventListener('mouseup', () => isMouseDown = false);
            document.addEventListener('mousemove', onMouseMove);

            isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            if (isTouchDevice) {
                document.getElementById('touch-controls').style.display = 'block';
                initTouchControls();
            }

            animate();
        }

        function initWorldSegments() {
            createSegmentAt(0);
            createSegmentAt(-SEGMENT_LENGTH);
            createSegmentAt(SEGMENT_LENGTH);
            minZ = -SEGMENT_LENGTH;
            maxZ = SEGMENT_LENGTH;
        }

        function rebuildWorld() {
            activeSegments.forEach(seg => {
                scene.remove(seg);
                seg.geometry.dispose();
                seg.material.dispose();
            });
            activeSegments = [];

            const currentGridZ = Math.round(camera.position.z / SEGMENT_LENGTH) * SEGMENT_LENGTH;
            minZ = currentGridZ;
            maxZ = currentGridZ;

            createSegmentAt(currentGridZ);
            createSegmentAt(currentGridZ - SEGMENT_LENGTH);
            createSegmentAt(currentGridZ + SEGMENT_LENGTH);
            
            minZ = currentGridZ - SEGMENT_LENGTH;
            maxZ = currentGridZ + SEGMENT_LENGTH;
        }

        function createSegmentAt(zPosition) {
            const points = [];
            const pointsCount = 150; 
            const turns = ConfigManager.current.springDensity; 
            const anglePerZ = (turns * Math.PI * 2) / SEGMENT_LENGTH;

            for (let i = 0; i <= pointsCount; i++) {
                const t = i / pointsCount;
                const z = zPosition - (t * SEGMENT_LENGTH); 
                const angle = z * anglePerZ;
                const x = Math.cos(angle) * SEGMENT_RADIUS;
                const y = Math.sin(angle) * SEGMENT_RADIUS;
                points.push(new THREE.Vector3(x, y, z));
            }

            const curve = new THREE.CatmullRomCurve3(points);
            
            // AUMENTADA LA RESOLUCIÓN GEOMÉTRICA PARA EVITAR LOOK POLIGONAL
            const geometry = new THREE.TubeGeometry(curve, 300, SEGMENT_RADIUS * 0.4, 32, false);

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0.0 },
                    uSpeed: { value: ConfigManager.current.speed },
                    uOpacityBase: { value: ConfigManager.current.opacityBase },
                    uFresnelIntensity: { value: ConfigManager.current.fresnelIntensity },
                    uColorSaturation: { value: ConfigManager.current.colorSaturation },
                    uColorScale: { value: ConfigManager.current.colorScale },
                    uBreathIntensity: { value: ConfigManager.current.breathIntensity },
                    uWaveFrequency: { value: ConfigManager.current.waveFrequency },
                    uTubeThickness: { value: ConfigManager.current.tubeThickness },
                    uAudioDisplace: { value: 0.0 } 
                },
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                side: THREE.BackSide, 
                transparent: true, 
                depthWrite: false,
                blending: THREE.AdditiveBlending 
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.userData = { startZ: zPosition }; 
            scene.add(mesh);
            activeSegments.push(mesh);
            activeSegments.sort((a, b) => b.userData.startZ - a.userData.startZ);
        }

        function updateProceduralGeneration() {
            const viewDistance = SEGMENT_LENGTH * 2;
            if (camera.position.z < minZ + viewDistance) {
                const newZ = minZ - SEGMENT_LENGTH;
                createSegmentAt(newZ);
                minZ = newZ;
            }
            if (camera.position.z > maxZ - viewDistance) {
                const newZ = maxZ + SEGMENT_LENGTH;
                createSegmentAt(newZ);
                maxZ = newZ;
            }
            const farLimit = SEGMENT_LENGTH * (VISIBLE_SEGMENTS + 1);
            for (let i = activeSegments.length - 1; i >= 0; i--) {
                const seg = activeSegments[i];
                const centerZ = seg.userData.startZ - (SEGMENT_LENGTH / 2);
                const dist = Math.abs(camera.position.z - centerZ);
                if (dist > farLimit) {
                    scene.remove(seg);
                    seg.geometry.dispose();
                    seg.material.dispose();
                    activeSegments.splice(i, 1);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. ACTUALIZAR AUDIO
            AudioSystem.update();

            // 2. MAPEO AUDIO -> VISUALES (ORGÁNICO)
            const r = ConfigManager.current.audioReactivity;
            
            const audioThickness = ConfigManager.current.tubeThickness + (AudioSystem.lows * 15.0 * r);
            const audioBreath = ConfigManager.current.breathIntensity + (AudioSystem.mids * 1.5 * r);
            const audioDisplace = AudioSystem.lows * 10.0 * r; 
            
            // Afectamos el color con los agudos
            const audioFresnel = ConfigManager.current.fresnelIntensity + (AudioSystem.highs * 1.0 * r);
            const audioSat = ConfigManager.current.colorSaturation + (AudioSystem.highs * 0.5 * r);

            const audioSpeedBoost = AudioSystem.volume * 200.0 * r;

            activeSegments.forEach(mesh => {
                if (mesh.material.uniforms) {
                    mesh.material.uniforms.uTime.value = time;
                    
                    // --- FIX OPACIDAD: Actualizar valor cada frame ---
                    mesh.material.uniforms.uOpacityBase.value = ConfigManager.current.opacityBase;
                    
                    // --- FIX ESCALA COLOR: Actualizar valor cada frame ---
                    mesh.material.uniforms.uColorScale.value = ConfigManager.current.colorScale;

                    mesh.material.uniforms.uTubeThickness.value = audioThickness;
                    mesh.material.uniforms.uBreathIntensity.value = audioBreath;
                    mesh.material.uniforms.uFresnelIntensity.value = audioFresnel;
                    mesh.material.uniforms.uColorSaturation.value = audioSat;
                    mesh.material.uniforms.uAudioDisplace.value = audioDisplace;
                    mesh.material.uniforms.uSpeed.value = ConfigManager.current.speed + (AudioSystem.volume * 2.0 * r);
                }
            });

            // --- MOVIMIENTO ---
            let targetSpeed = isTurbo ? TURBO_SPEED : NORMAL_SPEED;
            targetSpeed += audioSpeedBoost;

            if (moveForward) currentSpeed += (targetSpeed - currentSpeed) * 0.05;
            else if (moveBackward) currentSpeed += (-targetSpeed - currentSpeed) * 0.05;
            else currentSpeed += (0 - currentSpeed) * 0.05;

            // ROTACIÓN PITCH
            if (rotateLeft) pitch += 2.0 * dt;  
            if (rotateRight) pitch -= 2.0 * dt; 

            // Roll se mantiene en 0 o se endereza solo
            roll += (0 - roll) * 0.05;

            const forward = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation);
            const right = new THREE.Vector3(1, 0, 0).applyEuler(camera.rotation);
            const up = new THREE.Vector3(0, 1, 0).applyEuler(camera.rotation);

            const velocity = new THREE.Vector3();
            if (Math.abs(currentSpeed) > 0.1) velocity.addScaledVector(forward, currentSpeed * dt);
            
            if (moveLeft) velocity.addScaledVector(right, -NORMAL_SPEED * dt);
            if (moveRight) velocity.addScaledVector(right, NORMAL_SPEED * dt);
            if (moveUp) velocity.addScaledVector(up, NORMAL_SPEED * dt);
            if (moveDown) velocity.addScaledVector(up, -NORMAL_SPEED * dt);

            camera.position.add(velocity);

            const euler = new THREE.Euler(pitch, yaw, roll, 'YXZ');
            camera.quaternion.setFromEuler(euler);

            updateProceduralGeneration();

            renderer.render(scene, camera);
        }

        // --- INPUTS ---
        function onKeyDown(e) {
            switch(e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'KeyQ': rotateLeft = true; break; 
                case 'KeyE': rotateRight = true; break; 
                case 'KeyZ': moveUp = true; break;   
                case 'KeyX': moveDown = true; break; 
                case 'Space': isTurbo = true; break; 
            }
        }

        function onKeyUp(e) {
            switch(e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'KeyQ': rotateLeft = false; break;
                case 'KeyE': rotateRight = false; break;
                case 'KeyZ': moveUp = false; break;
                case 'KeyX': moveDown = false; break;
                case 'Space': isTurbo = false; break;
            }
        }

        function onMouseMove(e) {
            if (isMouseDown) {
                const sensitivity = 0.002;
                yaw -= e.movementX * sensitivity;
                pitch -= e.movementY * sensitivity;
                pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- TOUCH CONTROLS ---
        function initTouchControls() {
            joystickContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                joystickId = touch.identifier;
                joystickActive = true;
                const rect = joystickContainer.getBoundingClientRect();
                joystickCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
                updateJoystick(touch.clientX, touch.clientY);
            }, {passive: false});

            joystickContainer.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if(!joystickActive) return;
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === joystickId) {
                        updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                    }
                }
            }, {passive: false});

            hyperspaceBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isTurbo = true;
                hyperspaceBtn.style.transform = 'scale(0.9)';
                hyperspaceBtn.style.background = 'rgba(255, 255, 255, 0.4)';
            });
            hyperspaceBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                isTurbo = false;
                hyperspaceBtn.style.transform = 'scale(1)';
                hyperspaceBtn.style.background = 'radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, rgba(0,0,0,0) 60%)';
            });

            let lastTouchX = 0;
            let lastTouchY = 0;
            let lookTouchId = null;

            document.addEventListener('touchstart', (e) => {
                if (e.target.closest('#config-panel') || e.target.closest('#config-toggle') || e.target.closest('#audio-controls')) return;
                
                for(let i=0; i<e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if(t.target !== joystickKnob && t.target !== joystickContainer && t.target !== hyperspaceBtn) {
                        lookTouchId = t.identifier;
                        lastTouchX = t.clientX;
                        lastTouchY = t.clientY;
                    }
                }
            });

            document.addEventListener('touchmove', (e) => {
                for(let i=0; i<e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if(t.identifier === lookTouchId) {
                        e.preventDefault();
                        const dx = t.clientX - lastTouchX;
                        const dy = t.clientY - lastTouchY;
                        yaw -= dx * 0.005;
                        pitch -= dy * 0.005;
                        lastTouchX = t.clientX;
                        lastTouchY = t.clientY;
                    }
                }
            }, {passive: false});

            const endTouch = (e) => {
                for(let i=0; i<e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if(t.identifier === joystickId) {
                        joystickActive = false;
                        joystickId = null;
                        joystickKnob.style.transform = `translate(0,0)`;
                        moveForward = false; moveBackward = false; moveLeft = false; moveRight = false;
                    }
                    if(t.identifier === lookTouchId) lookTouchId = null;
                }
            };
            document.addEventListener('touchend', endTouch);
            document.addEventListener('touchcancel', endTouch);
        }

        function updateJoystick(cx, cy) {
            const dx = cx - joystickCenter.x;
            const dy = cy - joystickCenter.y;
            const dist = Math.min(joystickMaxRadius, Math.sqrt(dx*dx + dy*dy));
            const angle = Math.atan2(dy, dx);
            const kx = Math.cos(angle) * dist;
            const ky = Math.sin(angle) * dist;
            joystickKnob.style.transform = `translate(${kx}px, ${ky}px)`;
            
            const th = 0.3;
            const nx = kx / joystickMaxRadius;
            const ny = ky / joystickMaxRadius;
            
            if (ny < -th) moveForward = true; else moveForward = false;
            if (ny > th) moveBackward = true; else moveBackward = false;
            if (nx < -th) moveLeft = true; else moveLeft = false;
            if (nx > th) moveRight = true; else moveRight = false;
        }

        init();
    </script>
</body>
</html>
