<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sinfon√≠a Atlante del Eneagrama v1.2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Montserrat:wght@300;400;600&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #020408;
            color: #a0e0e0;
            font-family: 'Montserrat', sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background: radial-gradient(circle at center, #0a1525 0%, #020408 80%);
            cursor: crosshair;
        }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        /* Hide UI on Idle */
        #ui-layer.idle #gear-btn {
            opacity: 0;
            pointer-events: none;
        }

        /* --- GEAR BUTTON --- */
        #gear-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 30px;
            background: none;
            border: none;
            color: #ffd700;
            cursor: pointer;
            z-index: 100;
            pointer-events: auto;
            transition: opacity 0.5s ease, transform 0.3s ease;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        #gear-btn:hover {
            transform: rotate(90deg);
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        /* --- SETTINGS MODAL --- */
        #settings-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            width: 340px;
            max-height: 80vh;
            background: rgba(5, 20, 35, 0.95);
            backdrop-filter: blur(12px);
            border-radius: 20px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.6);
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 101;
            overflow: hidden;
        }

        #settings-panel.active {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) scale(1);
        }

        /* --- TABS --- */
        .panel-header {
            display: flex;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(255, 215, 0, 0.1);
        }
        .tab-btn {
            flex: 1;
            padding: 15px 0;
            background: none;
            border: none;
            color: #88cccc;
            font-family: 'Cinzel', serif;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.3s;
            border-bottom: 2px solid transparent;
        }
        .tab-btn:hover { background: rgba(255, 255, 255, 0.05); color: #fff; }
        .tab-btn.active { color: #ffd700; border-bottom: 2px solid #ffd700; background: rgba(255, 215, 0, 0.05); }
        
        .close-modal {
            position: absolute;
            top: 10px;
            right: 15px;
            color: #aaa;
            font-size: 20px;
            cursor: pointer;
            z-index: 102;
        }
        .close-modal:hover { color: #fff; }

        .panel-content {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .tab-content { display: none; animation: fadeIn 0.3s; }
        .tab-content.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        /* --- CONTROLS --- */
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 10px; text-transform: uppercase; margin-bottom: 5px; color: #88cccc; letter-spacing: 1px; }
        
        select, input[type="text"] {
            width: 100%; background: rgba(0, 5, 10, 0.6); color: #00ffff;
            border: 1px solid rgba(0, 255, 255, 0.2); border-radius: 8px; padding: 8px;
            font-family: 'Montserrat', sans-serif; margin-bottom: 10px; cursor: pointer; font-size: 12px;
        }

        input[type="range"] {
            width: 100%; accent-color: #ffd700; cursor: pointer;
            background: rgba(255,255,255,0.05); border-radius: 10px; height: 4px;
        }

        .vertical-slider-container {
            display: flex; align-items: center; justify-content: center; height: 120px; margin: 10px 0;
            background: rgba(0,0,0,0.2); border-radius: 12px; padding: 10px;
        }
        input[type=range][orient=vertical] { writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 8px; height: 100%; padding: 0 5px; }

        button.action-btn {
            background: rgba(0, 255, 255, 0.05); border: 1px solid rgba(0, 255, 255, 0.3); color: #00ffff;
            padding: 10px; font-family: 'Cinzel', serif; font-weight: bold; font-size: 11px;
            cursor: pointer; transition: all 0.3s; text-transform: uppercase; letter-spacing: 1px;
            width: 100%; margin-bottom: 8px; border-radius: 8px;
        }
        button.action-btn:hover { background: rgba(0, 255, 255, 0.15); box-shadow: 0 0 15px rgba(0, 255, 255, 0.2); border-color: #00ffff; }
        button.action-btn.active { background: rgba(0, 255, 255, 0.2); color: #fff; border-color: #00ffff; box-shadow: 0 0 20px rgba(0, 255, 255, 0.4); }
        
        #mute-btn { border-color: #ffd700; color: #ffd700; background: rgba(255,215,0,0.05); }
        #mute-btn:hover { background: rgba(255,215,0,0.15); }

        .key-hint { display: inline-block; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; padding: 2px 5px; font-size: 9px; margin-right: 6px; color: #00ffff; min-width: 18px; text-align: center; font-family: monospace; }
        .legend-item { display: flex; align-items: center; margin-bottom: 8px; font-size: 11px; color: #ccc; }

        /* --- OVERLAY & LOGO --- */
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(2, 4, 8, 0.95); z-index: 200;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
        }
        #start-btn { font-size: 24px; padding: 20px 50px; width: auto; border: 2px solid #ffd700; border-radius: 50px; letter-spacing: 4px; background: transparent; color: #ffd700; font-family: 'Cinzel', serif; cursor: pointer; transition: 0.3s; }
        #start-btn:hover { background: rgba(255,215,0,0.1); box-shadow: 0 0 30px rgba(255,215,0,0.3); }

        #logo-container {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 20;
            pointer-events: auto; text-align: center; opacity: 1; transition: opacity 2s ease-in-out; cursor: pointer;
        }
        #logo-container.faded { opacity: 0; pointer-events: auto; }
        .logo-text {
            font-family: 'Cinzel', serif; font-size: 18px; font-weight: bold; letter-spacing: 4px; text-transform: uppercase;
            background: linear-gradient(90deg, #ffd700, #00ffff, #b080ff, #ffd700); background-size: 300% 100%;
            -webkit-background-clip: text; background-clip: text; color: transparent;
            animation: rainbow-flow 4s linear infinite; text-shadow: 0 0 15px rgba(0,255,255,0.3);
        }
        @keyframes rainbow-flow { 0% { background-position: 0% 50%; } 100% { background-position: 100% 50%; } }
        
        .hz-display { font-family: 'monospace'; color: #00ffff; text-align: center; font-size: 14px; margin-top: 5px; }

        @media (max-width: 600px) {
            #settings-panel { width: 90%; }
        }
    </style>
</head>
<body>

    <div id="start-overlay">
        <h1 style="font-size: 40px; margin-bottom: 20px; color: #ffd700; text-shadow: 0 0 30px #ffd700; border:none; text-align: center;">Resonancia Atlante</h1>
        <p style="margin-bottom: 40px; color: #88cccc; font-family: 'Cinzel', serif;">Activaci√≥n Ancestral del Eneagrama</p>
        <button id="start-btn">Despertar el Cristal</button>
    </div>

    <div id="canvas-container">
        <canvas id="mainCanvas"></canvas>
    </div>

    <div id="logo-container" title="Click para revivir">
        <div class="logo-text">Chamalnquimyst labs</div>
    </div>

    <div id="ui-layer">
        <button id="gear-btn">‚öôÔ∏è</button>

        <div id="settings-panel">
            <span class="close-modal" onclick="closeSettings()">√ó</span>
            <div class="panel-header">
                <button class="tab-btn active" onclick="switchTab('tab-general')">Controles</button>
                <button class="tab-btn" onclick="switchTab('tab-manual')">Manual</button>
                <button class="tab-btn" onclick="switchTab('tab-tuning')">Afinaci√≥n</button>
            </div>
            
            <div class="panel-content">
                <div id="tab-general" class="tab-content active">
                    <button id="mute-btn" class="action-btn">üîä Sonido Activo</button>
                    <button id="auto-play-btn" class="action-btn">‚ñ∂ Iniciar Secuencia</button>
                    <div style="height:10px"></div>
                    <button id="3d-toggle-btn" class="action-btn">üåå Perspectiva 3D: OFF</button>
                    <button id="atomic-toggle-btn" class="action-btn">‚öõ Modo At√≥mico: OFF</button>
                    <button id="octave-toggle-btn" class="action-btn" style="border-color: #aa00ff; color: #aa00ff;">‚â° 1 Octava (Base)</button>
                    <button id="stereo-toggle-btn" class="action-btn" style="border-color: #ff00ff; color: #ff00ff;">üï∂ Estereograma: OFF</button>
                    <button id="hifi-toggle-btn" class="action-btn" style="border-color: #00ffaa; color: #00ffaa;">üì± Modo M√≥vil</button>

                    <div class="control-group">
                        <label for="vol-slider">Volumen Maestro</label>
                        <input type="range" id="vol-slider" min="0" max="1" step="0.01" value="0.5">
                    </div>
                    <div class="control-group">
                        <label for="tempo-slider">Ritmo (BPM): <span id="bpm-val">120</span></label>
                        <input type="range" id="tempo-slider" min="40" max="300" value="120">
                    </div>
                    <div class="control-group">
                        <label for="scale-select">Escala Vibratoria</label>
                        <select id="scale-select">
                            <option value="atlantis">Atlantis (M√≠stica)</option>
                            <option value="gurdjieff">Gurdjieff (Sagrada)</option>
                            <option value="sufi">Sufi (Hijaz)</option>
                            <option value="hang">Hang Drum (Kurds)</option>
                            <option value="custom">üõ† Personalizada</option>
                        </select>
                    </div>
                </div>

                <div id="tab-manual" class="tab-content">
                    <h3 style="color:#ffd700; font-family:'Cinzel',serif; margin-bottom:15px; border-bottom:1px solid #333;">Gu√≠a de Usuario</h3>
                    <div class="legend-item"><span class="key-hint">ESPACIO</span> Centro (Ley del 1)</div>
                    <div class="legend-item"><span class="key-hint">‚Üë</span><span class="key-hint">‚Üê</span><span class="key-hint">‚Üí</span> Tri√°ngulo (Ley del 3)</div>
                    <div class="legend-item">
                        <span class="key-hint">E</span>(1) <span class="key-hint">C</span>(4) <span class="key-hint">D</span>(2)
                        <span class="key-hint">Q</span>(8) <span class="key-hint">Z</span>(5) <span class="key-hint">A</span>(7)
                    </div>
                    <hr style="border-color: #333; margin: 10px 0;">
                    <p style="font-size: 11px; color: #aaa; line-height: 1.6;">
                        ‚Ä¢ <strong>Click Izquierdo / Toque:</strong> Toca la nota.<br>
                        ‚Ä¢ <strong>Arrastrar en 3D:</strong> Mueve el punto (Solo en modo 3D).<br>
                        ‚Ä¢ <strong>Click Derecho:</strong> Configuraci√≥n de nota.<br>
                        ‚Ä¢ <strong>Shift + Arrastrar:</strong> Zoom.
                    </p>
                </div>

                <div id="tab-tuning" class="tab-content">
                    <div class="control-group">
                        <label>Punto Seleccionado</label>
                        <select id="tune-node-select">
                            <option value="0">Centro (Ley del 1)</option>
                            <option value="1">Punto 1</option>
                            <option value="2">Punto 2</option>
                            <option value="3">Punto 3</option>
                            <option value="4">Punto 4</option>
                            <option value="5">Punto 5</option>
                            <option value="6">Punto 6</option>
                            <option value="7">Punto 7</option>
                            <option value="8">Punto 8</option>
                            <option value="9">Punto 9</option>
                        </select>
                        <p id="layer-info" style="font-size:9px; color:#aaa; margin-top:2px;">Capa: Principal</p>
                    </div>

                    <div class="control-group">
                        <label>Seleccionar Nota</label>
                        <div style="display: flex; gap: 5px;">
                            <select id="note-name" style="flex:2"><option value="C">C</option><option value="D">D</option><option value="E">E</option><option value="F">F</option><option value="G">G</option><option value="A">A</option><option value="B">B</option></select>
                            <select id="note-acc" style="flex:2"><option value="flat">‚ô≠</option><option value="natural" selected>‚ôÆ</option><option value="sharp">‚ôØ</option></select>
                            <select id="note-oct" style="flex:1"><option value="3">3</option><option value="4" selected>4</option><option value="5">5</option><option value="6">6</option></select>
                        </div>
                    </div>

                    <div class="control-group" style="text-align: center;">
                        <label>Afinaci√≥n Fina (Hz)</label>
                        <div class="vertical-slider-container">
                            <input type="range" id="hz-slider" orient="vertical" min="50" max="1000" step="0.1" value="261.6">
                        </div>
                        <div class="hz-display" id="hz-display">261.6 Hz</div>
                    </div>

                    <div class="control-group">
                        <label>Profundidad (Eje Z)</label>
                        <input type="range" id="z-slider" min="-1.5" max="1.5" step="0.05" value="0">
                    </div>

                    <button id="save-json-btn" class="action-btn" style="border-color: #00ff00; color: #00ff00;">Guardar (.JSON)</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- UI LOGIC ---
        const uiLayer = document.getElementById('ui-layer');
        const settingsPanel = document.getElementById('settings-panel');
        const gearBtn = document.getElementById('gear-btn');
        let idleTimer;

        // Idle Timer
        function resetIdleTimer() {
            uiLayer.classList.remove('idle');
            clearTimeout(idleTimer);
            idleTimer = setTimeout(() => { 
                if(!settingsPanel.classList.contains('active')) {
                    uiLayer.classList.add('idle'); 
                }
            }, 5000);
        }
        ['mousemove', 'mousedown', 'touchstart', 'keydown', 'click', 'wheel'].forEach(evt => window.addEventListener(evt, resetIdleTimer));

        gearBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            settingsPanel.classList.toggle('active');
        });

        function closeSettings() {
            settingsPanel.classList.remove('active');
        }

        function switchTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
            const btns = document.querySelectorAll('.tab-btn');
            if(tabId === 'tab-general') btns[0].classList.add('active');
            if(tabId === 'tab-manual') btns[1].classList.add('active');
            if(tabId === 'tab-tuning') btns[2].classList.add('active');
        }

        document.addEventListener('click', (e) => {
            if(settingsPanel.classList.contains('active') && !settingsPanel.contains(e.target) && e.target !== gearBtn) {
                closeSettings();
            }
        });

        // --- AUDIO ENGINE ---
        const AudioEngine = {
            ctx: null, masterGain: null, reverbNode: null, compressor: null, filterNode: null,
            isMuted: false, activeNotes: {}, hiFiMode: false, globalVol: 0.5,
            init() {
                try {
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = this.globalVol * 0.5;
                    this.filterNode = this.ctx.createBiquadFilter();
                    this.filterNode.type = 'highpass'; this.filterNode.frequency.value = 150; this.filterNode.Q.value = 0.7;
                    this.compressor = this.ctx.createDynamicsCompressor();
                    this.reverbNode = this.createReverb();
                    this.masterGain.connect(this.filterNode);
                    this.filterNode.connect(this.compressor);
                    this.compressor.connect(this.reverbNode);
                    this.reverbNode.connect(this.ctx.destination);
                } catch(e) { console.error("Init Failed", e); }
            },
            checkContext() { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); if (!this.ctx) this.init(); },
            setVolume(val) { this.globalVol = val; if(this.ctx && !this.isMuted) this.masterGain.gain.setTargetAtTime(val * 0.5, this.ctx.currentTime, 0.1); },
            toggleHiFi() { this.hiFiMode = !this.hiFiMode; if(this.ctx) { if(this.hiFiMode) { this.filterNode.frequency.setTargetAtTime(30, this.ctx.currentTime, 0.5); } else { this.filterNode.frequency.setTargetAtTime(150, this.ctx.currentTime, 0.5); } } return this.hiFiMode; },
            createReverb() { if (!this.ctx) return null; const c = this.ctx.createConvolver(); const l = this.ctx.sampleRate * 4; const b = this.ctx.createBuffer(2, l, this.ctx.sampleRate); const L = b.getChannelData(0); const R = b.getChannelData(1); for (let i = 0; i < l; i++) { const d = Math.pow(1 - i / l, 4); L[i] = (Math.random()*2-1)*d; R[i] = (Math.random()*2-1)*d; } c.buffer = b; return c; },
            toggleMute() { this.isMuted = !this.isMuted; if(this.ctx) this.masterGain.gain.setTargetAtTime(this.isMuted ? 0 : this.globalVol * 0.5, this.ctx.currentTime, 0.1); return this.isMuted; },
            startNote(id, freq, timbre = 'pure', detune = 0) {
                this.checkContext();
                if (!this.ctx || this.isMuted) return;
                if (this.activeNotes[id]) this.stopNote(id, 0.05);
                const env = this.ctx.createGain(); env.connect(this.masterGain);
                const oscs = [];
                if (timbre === 'pure') {
                    const o = this.ctx.createOscillator(); o.type = 'sine'; o.frequency.setValueAtTime(freq, this.ctx.currentTime); if(detune) o.detune.value=detune; o.connect(env); o.start(); oscs.push(o);
                    env.gain.setValueAtTime(0, this.ctx.currentTime); env.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 0.05);
                } else if (timbre === 'healing') {
                    const o1 = this.ctx.createOscillator(); o1.type = 'sine'; o1.frequency.setValueAtTime(freq, this.ctx.currentTime);
                    const o2 = this.ctx.createOscillator(); o2.type = 'sine'; o2.frequency.setValueAtTime(freq * 1.5, this.ctx.currentTime); 
                    const g1 = this.ctx.createGain(); g1.gain.value = 0.6; const g2 = this.ctx.createGain(); g2.gain.value = 0.15; 
                    o1.connect(g1); g1.connect(env); o2.connect(g2); g2.connect(env); o1.start(); o2.start(); oscs.push(o1, o2);
                    env.gain.setValueAtTime(0, this.ctx.currentTime); env.gain.linearRampToValueAtTime(0.25, this.ctx.currentTime + 0.4); 
                }
                this.activeNotes[id] = { oscs, env };
            },
            stopNote(id, releaseTime = 0.3) {
                if (!this.ctx || !this.activeNotes[id]) return;
                const { oscs, env } = this.activeNotes[id];
                env.gain.cancelScheduledValues(this.ctx.currentTime); 
                env.gain.setValueAtTime(env.gain.value, this.ctx.currentTime); 
                env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + releaseTime);
                oscs.forEach(o => o.stop(this.ctx.currentTime + releaseTime));
                setTimeout(() => { oscs.forEach(o => o.disconnect()); env.disconnect(); }, releaseTime * 1000 + 100);
                delete this.activeNotes[id];
            },
            triggerNote(id, freq, timbre, duration) { this.startNote(id, freq, timbre); setTimeout(() => { this.stopNote(id, 0.5); }, duration * 1000); }
        };

        // --- DATA ---
        const scales = {
            atlantis: [0, 261.63, 293.66, 311.13, 349.23, 392.00, 415.30, 466.16, 523.25, 622.25, 130.81],
            sufi:     [0, 261.63, 277.18, 329.63, 349.23, 392.00, 415.30, 466.16, 523.25, 554.37, 130.81], 
            hang:     [0, 261.63, 293.66, 311.13, 392.00, 466.16, 523.25, 587.33, 622.25, 783.99, 130.81],
            gurdjieff:[0, 261.63, 293.66, 311.13, 349.23, 392.00, 415.30, 493.88, 523.25, 587.33, 98.00] 
        };
        let customFrequencies = {}; scales.atlantis.forEach((f,i) => { if(i===10)customFrequencies[0]=f; else if(i>0)customFrequencies[i]=f; });
        let currentScaleName = 'atlantis';
        const connections = { 1: [4, 7], 4: [1, 2], 2: [4, 8], 8: [2, 5], 5: [8, 7], 7: [5, 1], 9: [3, 6], 3: [9, 6], 6: [3, 9] };

        // --- GRAPHICS ---
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        let width, height, centerX, centerY, radius;
        let is3DMode = false, isAtomicMode = false, isStereogramMode = false;
        let numOctaves = 1; 
        let globalRotationY = 0, zoomScale = 1.0;
        
        const COLOR_LAW_7 = "0, 255, 255"; 
        const COLOR_LAW_3 = "200, 0, 255"; 
        const COLOR_LAW_1 = "255, 215, 0"; 
        
        const nodes = [];
        const pulses = [];

        class Pulse {
            constructor(startNode, endNode) {
                this.startNode = startNode; this.endNode = endNode;
                this.progress = 0; this.speed = 0.04;
                this.color = startNode.type === 'law3' ? COLOR_LAW_3 : COLOR_LAW_7;
                this.dead = false;
            }
            update() {
                this.progress += this.speed; if (this.progress >= 1) { this.progress = 1; this.dead = true; }
            }
            draw(ctx) {
                if (!isOctaveMode && (this.startNode.layer !== 0 || this.endNode.layer !== 0)) return;
                const sx = this.startNode.screenX; const sy = this.startNode.screenY;
                const ex = this.endNode.screenX; const ey = this.endNode.screenY;
                const cx = sx + (ex - sx) * this.progress;
                const cy = sy + (ey - sy) * this.progress;
                const depthScale = (this.startNode.scale + this.endNode.scale) / 2;
                ctx.beginPath(); ctx.arc(cx, cy, 6 * depthScale, 0, Math.PI * 2);
                ctx.fillStyle = `rgb(${this.color})`; ctx.shadowBlur = 15 * depthScale; ctx.shadowColor = `rgb(${this.color})`; ctx.fill(); ctx.shadowBlur = 0;
                ctx.beginPath(); ctx.moveTo(cx, cy);
                const tx = cx - (ex - sx) * 0.15; const ty = cy - (ey - sy) * 0.15;
                ctx.lineTo(tx, ty); ctx.strokeStyle = `rgba(${this.color}, 0.5)`; ctx.lineWidth = 2 * depthScale; ctx.stroke();
            }
        }

        class Node {
            constructor(id, number, angleDeg, freqIndex, keyLabel, type, layer = 0) {
                this.id = id; this.number = number;
                this.angle = (angleDeg * Math.PI) / 180;
                this.freqIndex = freqIndex; this.keyLabel = keyLabel; this.type = type;
                this.layer = layer; 
                this.phi = 0; this.theta = this.angle;
                this.atomicOffset = 0;
                this.orbitSpeed = (Math.random() * 0.02 + 0.005) * (Math.random() > 0.5 ? 1 : -1);
                this.x3d = 0; this.y3d = 0; this.z3d = 0;
                this.screenX = 0; this.screenY = 0; this.scale = 1;
                this.isHeld = false; 
                this.isSustained = false;
                this.glow = 0;
                this.pressTime = 0;
            }

            update3D(baseR) {
                let r = baseR;
                if(this.layer === 1) r = baseR * 1.4; 
                if(this.layer === -1) r = baseR * 0.6; 

                if (this.number === 0) {
                    this.x3d = 0; this.y3d = 0; this.z3d = 0;
                } else {
                    const rSlice = r * Math.cos(this.phi);
                    this.x3d = rSlice * Math.cos(this.theta);
                    this.y3d = rSlice * Math.sin(this.theta);
                    this.z3d = r * Math.sin(this.phi);
                }
            }

            project(rotAngle, baseR, cx, cy, stereoOffsetAngle = 0) {
                this.update3D(baseR); 
                let x = this.x3d; let y = this.y3d; let z = this.z3d;
                let finalRot = rotAngle + stereoOffsetAngle;
                if (isAtomicMode) finalRot += this.atomicOffset;
                
                if (is3DMode || isAtomicMode || isStereogramMode) {
                    const cos = Math.cos(finalRot); const sin = Math.sin(finalRot);
                    const xRot = x * cos + z * sin;
                    const zRot = z * cos - x * sin;
                    const yRot = y;
                    const fl = baseR * 2.5;
                    let denom = fl - zRot;
                    if(denom < 10) denom = 10;
                    const scale = fl / denom;
                    return { x: cx + xRot * scale, y: cy + yRot * scale, scale: scale, z: zRot };
                } else {
                    // FLAT 2D PROJECTION (No perspective, just coordinates)
                    let rFlat = baseR;
                    if(this.layer === 1) rFlat = baseR * 1.4;
                    if(this.layer === -1) rFlat = baseR * 0.6;
                    let xFlat, yFlat;
                    if(this.number === 0) { xFlat=0; yFlat=0; }
                    else { xFlat = rFlat * Math.cos(this.theta); yFlat = rFlat * Math.sin(this.theta); }
                    return { x: cx + xFlat, y: cy + yFlat, scale: 1, z: 0 };
                }
            }

            getFrequency() {
                let base = (currentScaleName === 'custom') ? customFrequencies[this.number] : scales[currentScaleName][this.number===0?10:this.number];
                if(this.layer === 1) base *= 2;
                if(this.layer === -1) base *= 0.5;
                return base;
            }

            startPress() {
                if (this.isSustained) {
                    this.isSustained = false;
                    AudioEngine.stopNote(this.id, 0.05); 
                    this.isHeld = false;
                    this.glow = 0; 
                    return; 
                }
                this.isHeld = true; 
                this.pressTime = Date.now();
                this.glow = 1.0;
                let timbre = 'pure'; if (this.type === 'law3') timbre = 'healing';
                AudioEngine.startNote(this.id, this.getFrequency(), timbre);
                
                const now = Date.now();
                if (lastPressedInfo.num !== null && (now - lastPressedInfo.time < 2000) && lastPressedInfo.layer === this.layer) {
                    const adjs = connections[lastPressedInfo.num];
                    if (adjs && adjs.includes(this.number)) {
                        spawnPulse(lastPressedInfo.num, this.number, this.layer);
                    }
                }
                lastPressedInfo = { num: this.number, layer: this.layer, time: now };
            }

            endPress() {
                if (!this.isHeld) return; 
                this.isHeld = false;
                const duration = Date.now() - this.pressTime;
                if (duration > 3000) {
                    this.isSustained = true;
                    this.glow = 2.0; 
                } else {
                    this.isSustained = false;
                    AudioEngine.stopNote(this.id, 0.3);
                }
            }

            pulse() {
                this.glow = 1.0; let timbre = 'pure'; if (this.type === 'law3') timbre = 'healing';
                AudioEngine.triggerNote(this.id, this.getFrequency(), timbre, 0.5);
            }
        }

        let isOctaveMode = false;
        let lastPressedInfo = { num: null, layer: 0, time: 0 };
        function spawnPulse(fromNum, toNum, layer) {
            const n1 = nodes.find(n => n.number === fromNum && n.layer === layer);
            const n2 = nodes.find(n => n.number === toNum && n.layer === layer);
            if (n1 && n2) pulses.push(new Pulse(n1, n2));
        }

        function initNodes() {
            nodes.length = 0; 
            const layers = [-1, 0, 1]; 
            layers.forEach(layer => {
                nodes.push(new Node(`center_${layer}`, 0, 0, 10, '', 'law1', layer));
                const pointDefinitions = [
                    { num: 1, key: 'E', type: 'law7', freqIdx: 1 }, { num: 2, key: 'D', type: 'law7', freqIdx: 2 },
                    { num: 3, key: '‚Üí', type: 'law3', freqIdx: 3 }, { num: 4, key: 'C', type: 'law7', freqIdx: 4 },
                    { num: 5, key: 'Z', type: 'law7', freqIdx: 5 }, { num: 6, key: '‚Üê', type: 'law3', freqIdx: 6 },
                    { num: 7, key: 'A', type: 'law7', freqIdx: 7 }, { num: 8, key: 'Q', type: 'law7', freqIdx: 8 },
                    { num: 9, key: '‚Üë', type: 'law3', freqIdx: 9 },
                ];
                pointDefinitions.forEach(p => {
                    let angle = -90 + (p.num * 40);
                    let label = (layer === 0) ? p.key : '';
                    nodes.push(new Node(`p${p.num}_${layer}`, p.num, angle, p.freqIdx, label, p.type, layer));
                });
            });
        }

        function resize() {
            width = window.innerWidth; height = window.innerHeight;
            canvas.width = width; canvas.height = height;
            radius = Math.min(width, height) * 0.30; 
            nodes.forEach(n => n.update3D(radius));
        }

        function renderScene(cx, cy, r, stereoAngle) {
            const projMap = {};
            const layersToDraw = (numOctaves === 1) ? [0] : (numOctaves === 2 ? [0, 1] : [-1, 0, 1]);
            const activeNodes = nodes.filter(n => layersToDraw.includes(n.layer));

            activeNodes.forEach(n => {
                const p = n.project(globalRotationY, r, cx, cy, stereoAngle);
                if(!isStereogramMode) { n.screenX = p.x; n.screenY = p.y; n.scale = p.scale; }
                projMap[n.id] = p;
            });

            if(!isAtomicMode) {
                layersToDraw.forEach(layer => {
                    let rLayer = r;
                    if(layer === 1) rLayer = r * 1.4;
                    if(layer === -1) rLayer = r * 0.6;
                    
                    ctx.beginPath();
                    // If not 3D/Atomic/Stereo, use circle
                    if (!(is3DMode || isAtomicMode || isStereogramMode)) {
                        ctx.arc(cx, cy, rLayer, 0, Math.PI * 2);
                    } else {
                        // 3D Ring
                        for(let i=0; i<=60; i++) {
                            const theta = (i / 60) * Math.PI * 2;
                            const x = rLayer * Math.cos(theta); const y = rLayer * Math.sin(theta); const z = 0;
                            let finalRot = globalRotationY + stereoAngle;
                            let xRot = x * Math.cos(finalRot) + z * Math.sin(finalRot);
                            let zRot = z * Math.cos(finalRot) - x * Math.sin(finalRot);
                            
                            let fl = r*2.5; 
                            let denom = fl - zRot; if(denom<10) denom=10;
                            let scale = fl/denom;
                            
                            let px = cx + xRot * scale; let py = cy + y * scale;
                            if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                        }
                    }
                    let strokeCol = "rgba(255, 215, 0, 0.4)";
                    if(layer === 1) strokeCol = "rgba(0, 255, 255, 0.6)"; 
                    if(layer === -1) strokeCol = "rgba(255, 100, 0, 0.7)"; 
                    ctx.strokeStyle = strokeCol; ctx.lineWidth = layer===0 ? 2 : 1.5; ctx.stroke();

                    const pIds = {};
                    [1,2,3,4,5,6,7,8,9].forEach(num => {
                        const n = activeNodes.find(node => node.number === num && node.layer === layer);
                        if(n) pIds[num] = projMap[n.id];
                    });

                    if(pIds[9] && pIds[3] && pIds[6]) {
                        ctx.beginPath(); ctx.moveTo(pIds[9].x, pIds[9].y); ctx.lineTo(pIds[3].x, pIds[3].y); ctx.lineTo(pIds[6].x, pIds[6].y); ctx.closePath();
                        let col = layer===0 ? `rgba(${COLOR_LAW_3}, 0.5)` : (layer===1?"rgba(255,0,255,0.6)":"rgba(75,0,130,0.8)"); // Indigo Low
                        ctx.strokeStyle = col; ctx.lineWidth = layer===0 ? 2 : 1.5; ctx.stroke();
                    }

                    const seq = [1, 4, 2, 8, 5, 7];
                    if(pIds[1]) {
                        ctx.beginPath(); ctx.moveTo(pIds[1].x, pIds[1].y);
                        for(let i=1; i<seq.length; i++) { if(pIds[seq[i]]) ctx.lineTo(pIds[seq[i]].x, pIds[seq[i]].y); }
                        ctx.lineTo(pIds[1].x, pIds[1].y);
                        let col = layer===0 ? `rgba(${COLOR_LAW_7}, 0.5)` : (layer===1?"rgba(100,255,255,0.6)":"rgba(255,60,0,0.7)"); // Magma Low
                        ctx.strokeStyle = col; ctx.lineWidth = layer===0 ? 2 : 1.5; ctx.stroke();
                    }
                });
            }

            const sorted = [...activeNodes].sort((a, b) => (projMap[a.id]?.z || 0) - (projMap[b.id]?.z || 0));
            
            sorted.forEach(n => {
                const p = projMap[n.id];
                if(!p) return;
                
                if (n.isHeld) n.glow = Math.min(n.glow + 0.05, 1.2);
                else if (n.isSustained) { n.glow = 0.8 + Math.sin(Date.now() / 200) * 0.2; } 
                else { if (n.glow > 0) n.glow -= 0.05; if (n.glow < 0) n.glow = 0; }

                let baseSize = (n.number === 0 ? 15 : 8);
                if(n.layer !== 0) baseSize *= 0.8; 
                
                const size = (baseSize + (n.glow * 10)) * p.scale;
                
                let color = "255, 255, 255";
                if(n.layer === 0) {
                    if (n.type === 'law7') color = COLOR_LAW_7;
                    if (n.type === 'law3') color = COLOR_LAW_3;
                    if (n.type === 'law1') color = COLOR_LAW_1;
                } else if(n.layer === 1) { 
                    color = "0, 255, 255"; 
                } else { 
                    if (n.type === 'law3') color = "75, 0, 130"; 
                    else if (n.type === 'law7') color = "255, 60, 0"; 
                    else color = "255, 200, 0";
                }

                const alpha = Math.min(1, Math.max(0.1, p.scale));
                
                ctx.shadowBlur = n.glow * 30 * p.scale; ctx.shadowColor = `rgb(${color})`;
                ctx.beginPath(); ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${color}, ${0.8 * alpha})`; ctx.fill(); ctx.shadowBlur = 0;
                
                if (n.glow > 0.01) {
                    ctx.beginPath(); ctx.arc(p.x, p.y, size * 1.4, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(${color}, ${n.glow * 0.8})`; ctx.lineWidth = 2 * p.scale; ctx.stroke();
                }
                
                if (n.layer === 0 || n.isHeld || n.isSustained) {
                    if (n.number !== 0) {
                        ctx.fillStyle = `rgba(${color}, ${0.9 * alpha})`;
                        ctx.font = `bold ${Math.max(8, (10 + n.glow * 4) * p.scale)}px Montserrat`;
                        ctx.textAlign = "center"; ctx.textBaseline = "middle";
                        ctx.fillText(n.number.toString(), p.x, p.y);
                    }
                }
            });
        }

        function animate() {
            try {
                ctx.clearRect(0, 0, width, height);
                
                // ROTATION LOGIC: Only rotate if in a 3D mode
                const isStructure3D = is3DMode || isAtomicMode || isStereogramMode;
                if (isStructure3D) {
                    globalRotationY += 0.005;
                } else {
                    // Reset to flat
                    if (Math.abs(globalRotationY) > 0.01) {
                        globalRotationY *= 0.9;
                    } else {
                        globalRotationY = 0;
                    }
                }

                if (isAtomicMode) nodes.forEach(n => n.atomicOffset += n.orbitSpeed);

                const currentRadius = Math.min(width, height) * 0.35 * zoomScale; 

                if(isStereogramMode) {
                    const cxL = width * 0.25; const cy = height * 0.5;
                    const rS = currentRadius * 0.5;
                    renderScene(cxL, cy, rS, -0.05); 
                    const cxR = width * 0.75; 
                    renderScene(cxR, cy, rS, 0.05); 
                    ctx.beginPath(); ctx.moveTo(width/2, 0); ctx.lineTo(width/2, height);
                    ctx.strokeStyle = "rgba(255,255,255,0.1)"; ctx.lineWidth=1; ctx.stroke();
                } else {
                    const cx = width * 0.5; const cy = height * 0.5;
                    renderScene(cx, cy, currentRadius, 0); 
                }

                if(!isAtomicMode && !isStereogramMode) {
                    for (let i = pulses.length - 1; i >= 0; i--) {
                        pulses[i].update(); pulses[i].draw(ctx);
                        if (pulses[i].dead) pulses.splice(i, 1);
                    }
                }
            } catch(e) {
                console.error("Animation Loop Error caught:", e);
            }
            requestAnimationFrame(animate);
        }

        const Walker = { 
            currentHexad: 1, currentTri: 9, 
            nextHexadRandom() { const map = {1:4,4:2,2:8,8:5,5:7,7:1}; this.currentHexad = map[this.currentHexad]; return this.currentHexad; }, 
            nextTriRandom() { const opts = {9:[3,6],3:[9,6],6:[9,3]}; const c = opts[this.currentTri]; this.currentTri = c[Math.floor(Math.random()*c.length)]; return this.currentTri; } 
        };
        const Sequencer = { 
            timeoutId: null, bpm: 120, isPlaying: false, mode: 'alive', linearIndex: 0, linearSeq: [0, 1, 4, 2, 8, 5, 7, 0, 9, 3, 6],
            toggle() { if (this.isPlaying) this.stop(); else this.start(); },
            start() { this.isPlaying = true; this.linearIndex = 0; document.getElementById('auto-play-btn').innerText = "‚èπ Detener Flujo"; document.getElementById('auto-play-btn').classList.add('active'); if (this.mode === 'linear') this.scheduleLinear(); else this.scheduleAlive(); },
            stop() { this.isPlaying = false; clearTimeout(this.timeoutId); document.getElementById('auto-play-btn').innerText = "‚ñ∂ Iniciar Secuencia"; document.getElementById('auto-play-btn').classList.remove('active'); },
            scheduleAlive() { 
                if (!this.isPlaying || this.mode !== 'alive') return; 
                const beatMs = (60 / this.bpm) * 1000; 
                const r = Math.random(); 
                let mult = 1; if (r > 0.7) mult = 0.5; else if (r > 0.9) mult = 2; 
                const duration = beatMs * mult; 
                const pathRoll = Math.random(); 
                let targetNum = 0, prevNum = 0; 
                if (pathRoll < 0.60) { prevNum = Walker.currentHexad; targetNum = Walker.nextHexadRandom(); } 
                else if (pathRoll < 0.90) { prevNum = Walker.currentTri; targetNum = Walker.nextTriRandom(); } 
                else { targetNum = 0; } 

                let targetLayer = 0;
                if (numOctaves > 1) {
                    const layerRoll = Math.random();
                    if(numOctaves === 2) { targetLayer = layerRoll < 0.5 ? 0 : 1; }
                    else { targetLayer = layerRoll < 0.33 ? -1 : (layerRoll < 0.66 ? 0 : 1); }
                }

                const node = nodes.find(n => n.number === targetNum && n.layer === targetLayer); 
                if (node) {
                    node.pulse();
                    if (pathRoll < 0.90) spawnPulse(prevNum, targetNum, targetLayer);
                } 
                this.timeoutId = setTimeout(() => this.scheduleAlive(), duration); 
            },
            scheduleLinear() { 
                if (!this.isPlaying || this.mode !== 'linear') return; 
                const beatMs = (60 / this.bpm) * 1000; 
                const targetNum = this.linearSeq[this.linearIndex]; 
                const node = nodes.find(n => n.number === targetNum && n.layer === 0); 
                if (node) { 
                    node.pulse(); 
                    const prevIdx = (this.linearIndex - 1 + this.linearSeq.length) % this.linearSeq.length; 
                    const prevNum = this.linearSeq[prevIdx]; 
                    const adjs = connections[prevNum]; 
                    if (adjs && adjs.includes(targetNum)) spawnPulse(prevNum, targetNum, 0); 
                } 
                this.linearIndex = (this.linearIndex + 1) % this.linearSeq.length; 
                this.timeoutId = setTimeout(() => this.scheduleLinear(), beatMs); 
            },
            setBpm(val) { this.bpm = val; }, setMode(val) { this.mode = val; if(this.isPlaying) { clearTimeout(this.timeoutId); this.linearIndex = 0; if(val === 'linear') this.scheduleLinear(); else this.scheduleAlive(); } }
        };

        const tuningPanel = document.getElementById('tuning-panel');
        const sliderHz = document.getElementById('hz-slider');
        const sliderZ = document.getElementById('z-slider');
        const noteSelect = document.getElementById('note-name');
        const displayHz = document.getElementById('hz-display');
        const layerInfo = document.getElementById('layer-info');
        const octaveBtn = document.getElementById('octave-toggle-btn');
        let selectedTuneNode = null;
        let draggingNode = null;
        let touchLongPressTimer = null;
        let touchStartPos = { x: 0, y: 0 };
        let isTouchDrag = false;
        let pinchStartDist = 0;
        let startZoomScale = 1;

        octaveBtn.addEventListener('click', (e) => {
            numOctaves = (numOctaves % 3) + 1; // 1 -> 2 -> 3 -> 1
            isOctaveMode = numOctaves > 1; 
            let label = "1 Octava (Base)";
            if(numOctaves === 2) label = "2 Octavas (+Alta)";
            if(numOctaves === 3) label = "3 Octavas (Total)";
            e.target.innerText = "‚â° " + label;
            if(numOctaves > 1) e.target.classList.add('active'); else e.target.classList.remove('active');
            // NO ROTATION TRIGGER HERE - Kept 2D
        });

        document.getElementById('stereo-toggle-btn').addEventListener('click', (e) => { isStereogramMode = !isStereogramMode; e.target.innerText = isStereogramMode ? "üï∂ Estereograma: ON" : "üï∂ Estereograma: OFF"; e.target.classList.toggle('active', isStereogramMode); });
        
        document.getElementById('3d-toggle-btn').addEventListener('click', (e) => { 
            is3DMode = !is3DMode; 
            if(is3DMode) { 
                isAtomicMode = false; 
                document.getElementById('atomic-toggle-btn').classList.remove('active'); 
                document.getElementById('atomic-toggle-btn').innerText = "‚öõ Modo At√≥mico: OFF"; 
            } 
            e.target.innerText = is3DMode ? "üåå Perspectiva 3D: ON" : "üåå Perspectiva 3D: OFF"; 
            e.target.classList.toggle('active', is3DMode); 
        });

        document.getElementById('atomic-toggle-btn').addEventListener('click', (e) => { 
            isAtomicMode = !isAtomicMode; 
            if(isAtomicMode) { 
                is3DMode = false; 
                document.getElementById('3d-toggle-btn').classList.remove('active'); 
                document.getElementById('3d-toggle-btn').innerText = "üåå Perspectiva 3D: OFF"; 
            } 
            e.target.innerText = isAtomicMode ? "‚öõ Modo At√≥mico: ON" : "‚öõ Modo At√≥mico: OFF"; 
            e.target.classList.toggle('active', isAtomicMode); 
        });

        document.getElementById('hifi-toggle-btn').addEventListener('click', (e) => { const isHiFi = AudioEngine.toggleHiFi(); if(isHiFi) { e.target.innerText = "üîä Modo Hi-Fi (Activo)"; e.target.style.borderColor = "#ff0088"; e.target.style.color = "#ff0088"; } else { e.target.innerText = "üì± Modo M√≥vil (Seguro)"; e.target.style.borderColor = "#00ffaa"; e.target.style.color = "#00ffaa"; } });
        document.getElementById('vol-slider').addEventListener('input', (e) => { AudioEngine.setVolume(parseFloat(e.target.value)); });
        
        document.getElementById('scale-select').addEventListener('change', (e) => {
            currentScaleName = e.target.value;
        });

        function openTuningForNode(node) {
            document.getElementById('scale-select').value = 'custom';
            settingsPanel.classList.add('active');
            switchTab('tab-tuning');
            currentScaleName = 'custom';
            selectedTuneNode = node;
            document.getElementById('tune-node-select').value = node.number;
            let lText = "Capa: Principal"; if(node.layer === 1) lText = "Capa: Octava Alta (Externa)"; if(node.layer === -1) lText = "Capa: Octava Baja (Interna)";
            layerInfo.innerText = lText;
            updateTuningUI();
        }
        function updateTuningUI() { 
            if(!selectedTuneNode) return;
            const freq = selectedTuneNode.getFrequency(); 
            sliderHz.value = freq; 
            displayHz.innerText = freq.toFixed(1) + " Hz";
            sliderZ.value = selectedTuneNode.phi;
        }
        sliderHz.addEventListener('input', (e) => { if(selectedTuneNode) { customFrequencies[selectedTuneNode.number] = parseFloat(e.target.value); displayHz.innerText = e.target.value + " Hz"; }});
        sliderHz.addEventListener('change', () => { if(selectedTuneNode) { AudioEngine.triggerNote(selectedTuneNode.id, parseFloat(sliderHz.value), 'pure', 0.5); } });
        sliderZ.addEventListener('input', (e) => { if(selectedTuneNode) selectedTuneNode.phi = parseFloat(e.target.value); });

        function getHitNode(mouseX, mouseY) {
            if(isStereogramMode) return null; 
            const sortedNodes = [...nodes].sort((a, b) => (numOctaves>1 || (a.layer===0 && b.layer===0)) ? b.scale - a.scale : 0);
            const layersToDraw = (numOctaves === 1) ? [0] : (numOctaves === 2 ? [0, 1] : [-1, 0, 1]);
            const visible = sortedNodes.filter(n => layersToDraw.includes(n.layer));
            for (let n of visible) {
                const dist = Math.sqrt(Math.pow(mouseX - n.screenX, 2) + Math.pow(mouseY - n.screenY, 2));
                const touchRadius = (n.number === 0 ? 30 : 20) * n.scale;
                if (dist < touchRadius) return n;
            }
            return null;
        }

        canvas.addEventListener('mousedown', (e) => {
            if(e.button === 2) return; 
            if(e.shiftKey) { isTouchDrag = true; touchStartPos = { x: e.clientX, y: e.clientY }; startZoomScale = zoomScale; return; }
            const clicked = getHitNode(e.clientX, e.clientY);
            if (clicked) { draggingNode = clicked; clicked.startPress(); } 
        });

        canvas.addEventListener('contextmenu', (e) => { 
            const clicked = getHitNode(e.clientX, e.clientY); 
            if (clicked) { 
                e.preventDefault(); 
                openTuningForNode(clicked); 
            } 
        });

        canvas.addEventListener('mousemove', (e) => {
            if(e.shiftKey && isTouchDrag) { const deltaY = (touchStartPos.y - e.clientY) * 0.005; zoomScale = Math.max(0.2, Math.min(3.0, startZoomScale + deltaY)); return; }
            
            // FIX: Only allow moving depth if in 3D Mode
            if(draggingNode && is3DMode) { 
                const delta = e.movementY * 0.01; 
                draggingNode.phi -= delta; 
                if(draggingNode.phi > 1.5) draggingNode.phi = 1.5; 
                if(draggingNode.phi < -1.5) draggingNode.phi = -1.5; 
                if(selectedTuneNode === draggingNode) sliderZ.value = draggingNode.phi; 
            }
        });
        window.addEventListener('mouseup', () => { if(draggingNode) { draggingNode.endPress(); draggingNode = null; } isTouchDrag = false; });

        // TOUCH HANDLING
        const activeTouchMap = {};
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); AudioEngine.checkContext();
            if (e.touches.length === 2) { const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; pinchStartDist = Math.sqrt(dx*dx + dy*dy); startZoomScale = zoomScale; return; }
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i]; const clicked = getHitNode(t.clientX, t.clientY);
                if(clicked) {
                    activeTouchMap[t.identifier] = clicked;
                    clicked.startPress();
                }
            }
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 2) { const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; const dist = Math.sqrt(dx*dx + dy*dy); const ratio = dist / pinchStartDist; zoomScale = Math.max(0.2, Math.min(3.0, startZoomScale * ratio)); }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
             e.preventDefault();
             for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i]; 
                const n = activeTouchMap[t.identifier];
                if(n) {
                    n.endPress();
                    delete activeTouchMap[t.identifier];
                }
             }
        }, { passive: false });

        document.getElementById('start-btn').addEventListener('click', () => { AudioEngine.init(); document.getElementById('start-overlay').style.display = 'none'; initNodes(); resize(); animate(); resetIdleTimer(); });
        document.getElementById('mute-btn').addEventListener('click', (e) => { const muted = AudioEngine.toggleMute(); e.target.innerText = muted ? "üîá Silenciado" : "üîä Sonido Activo"; e.target.classList.toggle('active', !muted); });
        document.getElementById('auto-play-btn').addEventListener('click', () => { AudioEngine.checkContext(); Sequencer.toggle(); });
        document.getElementById('save-json-btn').addEventListener('click', () => { const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(customFrequencies, null, 2)); const dlAnchorElem = document.createElement('a'); dlAnchorElem.setAttribute("href", dataStr); dlAnchorElem.setAttribute("download", "afinacion_eneagrama.json"); dlAnchorElem.click(); });
        
        window.addEventListener('resize', resize);
    </script>
</body>
</html>
